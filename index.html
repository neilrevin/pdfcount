<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Analysis & Editing Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- PDF.js for text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <!-- pdf-lib.js for merging PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script>
        // Set the workerSrc for pdf.js. This is required.
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .extracted-text { white-space: pre-wrap; word-wrap: break-word; }
        .remove-btn { line-height: 1; }
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 1rem; }
        [draggable="true"] { cursor: grab; }
        .dragging { opacity: 0.5; }
    </style>
</head>
<body class="bg-slate-900 text-slate-300 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto bg-slate-800 rounded-2xl shadow-lg p-6 md:p-8 border border-slate-700">
        
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-100">PDF Analysis & Editing Suite</h1>
            <p class="text-slate-400 mt-2">Analyze, reorder, and merge your PDF files.</p>
        </div>

        <!-- File Upload Section -->
        <div class="bg-slate-900 border-2 border-dashed border-slate-600 rounded-xl p-6 text-center">
            <input type="file" id="fileInput" multiple accept=".pdf" class="hidden">
            <label for="fileInput" class="cursor-pointer inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                Choose PDF Files
            </label>
            <p id="upload-notification" class="mt-3 text-sm text-amber-500 hidden"></p>
        </div>

        <!-- File List Section -->
        <div id="file-list-container" class="mt-4 space-y-2"></div>

        <!-- Action Button -->
        <div class="mt-6 text-center">
            <button id="startButton" class="w-full md:w-auto bg-green-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-700 transition-transform transform hover:scale-105 disabled:bg-slate-600 disabled:cursor-not-allowed disabled:transform-none" disabled>
                Analyze Files
            </button>
        </div>

        <!-- Results Section -->
        <div id="results" class="mt-8 hidden">
            <h2 class="text-2xl font-bold text-slate-100 mb-4">Your Files</h2>
            <p class="text-slate-400 mb-4 text-sm">Drag and drop files to reorder them for merging.</p>
            <div id="loader" class="text-center hidden my-4">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-500"></div>
                <p class="text-slate-400 mt-2">Processing files... this might take a moment.</p>
            </div>
            <div id="result-list" class="space-y-4"></div>
            <div id="total-count" class="mt-6 bg-indigo-900/50 p-4 rounded-lg hidden">
                 <h3 class="text-xl font-bold text-slate-100 mb-3 text-center">Grand Totals</h3>
                <div id="total-stats-grid"></div>
            </div>
            <!-- Merge Section -->
            <div id="merge-section" class="mt-6 text-center hidden">
                 <button id="mergeButton" class="w-full md:w-auto bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 transition-transform transform hover:scale-105">
                    Merge PDF Files
                </button>
                <p id="merge-size-info" class="text-xs text-slate-500 mt-2"></p>
                <div id="merge-status" class="mt-2">
                    <p id="merge-loader" class="text-slate-400 hidden">Working on it...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
    window.addEventListener('DOMContentLoaded', () => {
        // All DOM elements
        const elements = {
            fileInput: document.getElementById('fileInput'),
            startButton: document.getElementById('startButton'),
            fileListContainer: document.getElementById('file-list-container'),
            uploadNotification: document.getElementById('upload-notification'),
            resultsDiv: document.getElementById('results'),
            resultList: document.getElementById('result-list'),
            totalCountDiv: document.getElementById('total-count'),
            totalStatsGrid: document.getElementById('total-stats-grid'),
            loader: document.getElementById('loader'),
            mergeSection: document.getElementById('merge-section'),
            mergeButton: document.getElementById('mergeButton'),
            mergeLoader: document.getElementById('merge-loader'),
            mergeSizeInfo: document.getElementById('merge-size-info'),
        };

        let selectedFiles = [];
        let currentResults = [];
        const FILE_LIMIT = 100;

        // --- Event Listeners ---
        elements.fileInput.addEventListener('change', handleFileSelection);
        elements.startButton.addEventListener('click', analyzeFiles);
        elements.mergeButton.addEventListener('click', mergeFiles);

        function handleFileSelection(event) {
            let files = Array.from(event.target.files);
            elements.uploadNotification.classList.add('hidden');
            if (files.length > FILE_LIMIT) {
                elements.uploadNotification.textContent = `Max ${FILE_LIMIT} files. Only the first ${FILE_LIMIT} were added.`;
                elements.uploadNotification.classList.remove('hidden');
                files = files.slice(0, FILE_LIMIT);
            }
            selectedFiles = files;
            currentResults = [];
            elements.resultsDiv.classList.add('hidden');
            renderFileList();
            updateStartButtonState();
        }

        async function analyzeFiles() {
            if (selectedFiles.length === 0) return;
            setLoadingState(true);
            const fileResults = [];
            for (const file of selectedFiles) {
                const result = await processPdf(file);
                fileResults.push({ name: file.name, size: file.size, ...result });
            }
            currentResults = fileResults;
            setLoadingState(false);
            displayResults();
        }

        async function mergeFiles() {
            if (currentResults.length < 1) return;
            elements.mergeLoader.textContent = 'Merging files...';
            elements.mergeLoader.classList.remove('hidden', 'text-red-500');
            elements.mergeButton.disabled = true;

            try {
                const { PDFDocument } = PDFLib;
                const mergedPdf = await PDFDocument.create();
                let corruptFile = null;

                for (const result of currentResults) {
                    try {
                        const file = selectedFiles.find(f => f.name === result.name);
                        const pdfBytes = await file.arrayBuffer();
                        const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
                        const copiedPages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
                        copiedPages.forEach(page => mergedPdf.addPage(page));
                    } catch (fileError) {
                        corruptFile = result.name;
                        console.error(`Failed to process ${result.name}:`, fileError);
                        break;
                    }
                }

                if (corruptFile) {
                    throw new Error(`File "${truncateFilename(corruptFile, 40)}" may be corrupt.`);
                }
                
                const mergedPdfBytes = await mergedPdf.save();
                downloadFile(mergedPdfBytes, 'merged.pdf', "application/pdf");
                elements.mergeLoader.classList.add('hidden');

            } catch (error) {
                console.error("Failed to merge PDFs:", error);
                elements.mergeLoader.textContent = `Error: ${error.message}`;
                elements.mergeLoader.classList.add('text-red-500');
            } finally {
                elements.mergeButton.disabled = false;
            }
        }

        // --- UI Update Functions ---
        function renderFileList() {
            elements.fileListContainer.innerHTML = '';
            if (selectedFiles.length > 0) {
                const list = document.createElement('ul');
                list.className = 'space-y-2';
                selectedFiles.forEach((file, index) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'flex items-center justify-between bg-slate-700 p-2 rounded-md';
                    listItem.innerHTML = `
                        <span class="text-slate-300 text-sm truncate" title="${file.name}">${truncateFilename(file.name, 35)}</span>
                        <button class="remove-btn text-slate-400 hover:text-red-500 p-1 rounded-full text-xl" data-index="${index}" title="Remove file">&times;</button>
                    `;
                    list.appendChild(listItem);
                });
                elements.fileListContainer.appendChild(list);
                document.querySelectorAll('.remove-btn').forEach(button => {
                    button.addEventListener('click', (e) => removeFile(parseInt(e.currentTarget.dataset.index, 10)));
                });
            }
        }
        
        function removeFile(indexToRemove) {
            selectedFiles.splice(indexToRemove, 1);
            if(currentResults.length > indexToRemove) currentResults.splice(indexToRemove, 1);
            renderFileList();
            updateStartButtonState();
            if (!elements.resultsDiv.classList.contains('hidden')) displayResults();
        }

        function updateStartButtonState() {
            elements.startButton.disabled = selectedFiles.length === 0;
        }

        function displayResults() {
            elements.resultList.innerHTML = '';
            if (currentResults.length === 0) {
                elements.resultsDiv.classList.add('hidden');
                return;
            }
            
            currentResults.forEach((result, index) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'bg-slate-700/50 p-4 rounded-lg';
                resultItem.setAttribute('draggable', 'true');
                resultItem.dataset.index = index;
                
                resultItem.innerHTML = `
                    <div class="flex items-start justify-between mb-4">
                        <h3 class="text-lg font-bold text-slate-100 truncate pr-4" title="${result.name}">${truncateFilename(result.name, 40)}</h3>
                        <div class="flex space-x-2 flex-shrink-0">
                           <button class="toggle-text-btn px-3 py-1 text-sm font-medium text-indigo-400 bg-indigo-900/50 rounded-md hover:bg-indigo-900/80">Show Text</button>
                        </div>
                    </div>
                    <div class="stat-grid">
                        <div><span class="text-slate-400 text-sm">Words</span><p class="font-semibold text-lg text-indigo-400">${result.wordCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Pages</span><p class="font-semibold text-lg">${result.pageCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Characters</span><p class="font-semibold text-lg">${result.characterCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Sentences</span><p class="font-semibold text-lg">${result.sentenceCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Paragraphs</span><p class="font-semibold text-lg">${result.paragraphCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Reading Time</span><p class="font-semibold text-lg">${formatTime(result.readingTime)}</p></div>
                    </div>
                    <div class="extracted-text-container hidden mt-4 border-t border-slate-600 pt-4">
                        <pre class="extracted-text text-sm text-slate-300 bg-slate-900/50 p-3 rounded-md max-h-60 overflow-y-auto">${document.createTextNode(result.text).textContent}</pre>
                    </div>
                `;
                elements.resultList.appendChild(resultItem);
            });

            updateTotals();
            addResultEventListeners();
        }
        
        function updateTotals() {
            const totals = currentResults.reduce((acc, result) => {
                acc.wordCount += result.wordCount;
                acc.characterCount += result.characterCount;
                acc.sentenceCount += result.sentenceCount;
                acc.paragraphCount += result.paragraphCount;
                acc.pageCount += result.pageCount;
                acc.readingTime += result.readingTime;
                acc.size += result.size;
                return acc;
            }, { wordCount: 0, characterCount: 0, sentenceCount: 0, paragraphCount: 0, pageCount: 0, readingTime: 0, size: 0 });

            if (currentResults.length > 1) {
                elements.totalStatsGrid.innerHTML = `
                    <div class="stat-grid">
                        <div><span class="text-slate-400 text-sm">Words</span><p class="font-semibold text-lg text-indigo-400">${totals.wordCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Pages</span><p class="font-semibold text-lg">${totals.pageCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Characters</span><p class="font-semibold text-lg">${totals.characterCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Sentences</span><p class="font-semibold text-lg">${totals.sentenceCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Paragraphs</span><p class="font-semibold text-lg">${totals.paragraphCount.toLocaleString()}</p></div>
                        <div><span class="text-slate-400 text-sm">Reading Time</span><p class="font-semibold text-lg">${formatTime(totals.readingTime)}</p></div>
                    </div>`;
                elements.totalCountDiv.classList.remove('hidden');
                elements.mergeSection.classList.remove('hidden');
                elements.mergeSizeInfo.textContent = `Estimated download size: ${formatBytes(totals.size)}`;
            } else {
                elements.totalCountDiv.classList.add('hidden');
                elements.mergeSection.classList.add('hidden');
            }
        }

        // --- Drag and Drop ---
        function addDragAndDropListeners() {
            const draggables = elements.resultList.querySelectorAll('[draggable="true"]');
            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', () => draggable.classList.add('dragging'));
                draggable.addEventListener('dragend', () => draggable.classList.remove('dragging'));
            });

            elements.resultList.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(elements.resultList, e.clientY);
                const dragging = document.querySelector('.dragging');
                if (afterElement == null) {
                    elements.resultList.appendChild(dragging);
                } else {
                    elements.resultList.insertBefore(dragging, afterElement);
                }
            });

            elements.resultList.addEventListener('drop', () => {
                const newOrder = Array.from(elements.resultList.querySelectorAll('[draggable="true"]')).map(el => {
                    const originalName = selectedFiles[parseInt(el.dataset.index)].name;
                    return currentResults.find(r => r.name === originalName);
                });
                currentResults = newOrder;
                selectedFiles = newOrder.map(r => selectedFiles.find(f => f.name === r.name));
                displayResults();
            });
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('[draggable="true"]:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- Helpers ---
        function addResultEventListeners() {
            document.querySelectorAll('.toggle-text-btn').forEach((button) => {
                button.addEventListener('click', (e) => {
                    const container = e.target.closest('.bg-slate-700\\/50').querySelector('.extracted-text-container');
                    container.classList.toggle('hidden');
                    e.target.textContent = container.classList.contains('hidden') ? 'Show Text' : 'Hide Text';
                });
            });
            addDragAndDropListeners();
        }

        function setLoadingState(isLoading) {
            if (isLoading) {
                elements.resultsDiv.classList.remove('hidden');
                elements.loader.classList.remove('hidden');
                elements.startButton.disabled = true;
            } else {
                elements.loader.classList.add('hidden');
                elements.startButton.disabled = false;
            }
        }

        async function processPdf(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const pdfData = new Uint8Array(event.target.result);
                        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
                        let fullText = '';
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            fullText += textContent.items.map(item => item.str).join(' ') + '\n\n';
                        }
                        const wordCount = countWordsInText(fullText);
                        resolve({
                            wordCount: wordCount,
                            characterCount: fullText.length,
                            sentenceCount: fullText.match(/[.!?…]+/g)?.length || 0,
                            paragraphCount: fullText.split(/\n\s*\n+/).filter(p => p.trim().length > 0).length,
                            pageCount: pdf.numPages,
                            readingTime: (wordCount / 225) * 60,
                            speakingTime: (wordCount / 150) * 60,
                            text: fullText.trim()
                        });
                    } catch (error) {
                        console.error(`Error processing ${file.name}:`, error);
                        resolve({ wordCount: 0, characterCount: 0, sentenceCount: 0, paragraphCount: 0, pageCount: 0, readingTime: 0, speakingTime: 0, text: 'Error processing this file.' });
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }
        
        const countWordsInText = (text) => text?.match(/\S+/g)?.length || 0;
        const formatTime = (totalSeconds) => {
            if (totalSeconds === 0) return '0s';
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = Math.round(totalSeconds % 60);
            return [h > 0 ? `${h}h` : '', m > 0 ? `${m}m` : '', s > 0 ? `${s}s` : ''].filter(Boolean).join(' ').trim() || '0s';
        };
        const formatBytes = (bytes, decimals = 2) => {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
        const truncateFilename = (name, len) => name.length > len ? `${name.substring(0, len-15)}...${name.substring(name.length-10)}` : name;
        const downloadFile = (data, filename, type) => {
            const blob = new Blob([data], { type: type });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
        };
    });
    </script>
</body>
</html>
